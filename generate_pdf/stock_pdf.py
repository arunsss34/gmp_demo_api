import base64
import os
import uuid
from fpdf import FPDF
from db_connection import py_connection
from PyPDF2 import PdfWriter, PdfReader
from report.py_stock_rpt import get_stock_report_table
from decimal import Decimal
from datetime import datetime as dt, timedelta
from collections import defaultdict


def file_to_base64(file_path):
    try:
        with open(file_path, 'rb') as file:
            file_content = file.read()
            base64_encoded = base64.b64encode(file_content)
            base64_string = base64_encoded.decode('utf-8')
            return base64_string
    except Exception as e:
        return {"status": "error", "message": str(e)}

class PDF(FPDF):
    def footer(self):
        self.set_y(-15)  # Position 15 mm from the bottom
        self.set_font("Arial", "", 8)
        self.cell(0, 5, "PDF generated by:", ln=True, align='L')
        self.cell(0, 5, "www.innalytics.in", ln=True, align='L')

# Lucky Yarns Customer PO and Frame Wise Report

def generate_stock_pdf(request, decoded):
    if request['type'] == 3:
        frame_stock_report = get_frame_stock_report_report_table(request, decoded)
        details = frame_stock_report.get('details')
        rpt_name = frame_stock_report.get('rpt_name')
        file_name = frame_stock_report.get('file_name')
        stock_pdf = get_frame_pdf(details, request, rpt_name, decoded)
        return {"base64string": file_to_base64(stock_pdf), "file_name": str(file_name) + ".Pdf"}
    else:
        stock_report = get_stock_report_table(request, decoded)
        details = stock_report.get('details')
        rpt_name = stock_report.get('rpt_name')
        file_name = stock_report.get('file_name')
        if request['type'] == 1:
            stock_pdf = get_item_pdf(details, request, rpt_name, decoded)
        else:
            stock_pdf = get_category_pdf(details, request, rpt_name, decoded)
        return {"base64string": file_to_base64(stock_pdf), "file_name": str(file_name) + ".Pdf"}

def get_category_pdf(details, request, rpt_name, decoded):
    try:
        if isinstance(details, tuple) and len(details) > 0:
            details = details[0]  # Assuming the list of dictionaries is the first element of the tuple

            # Debugging output
        print("Details received:", details)

        if not details or not isinstance(details, list) or not isinstance(details[0], dict):
            print("Invalid format for details. Expected a list of dictionaries.")
            return None

        # Initialize PDF
        pdf = PDF()
        pdf.add_page()

        # Title
        pdf.set_font("Arial", "B", 12)
        pdf.cell(0, 10, decoded.get('comp_name', 'Company Name'), ln=True, align='C')
        pdf.ln(5)

        date = dt.now()
        formatted_date = date.strftime("%d-%m-%Y %I:%M %p")

        # Report Name
        pdf.set_font("Arial", "B", 10)
        pdf.cell(0, 10, str(rpt_name) +' '+ str(formatted_date), ln=True, align='C')
        pdf.ln(10)

        # Table Headers
        pdf.set_font("Arial", "B", 9)

        # Extract headers from the keys of the first item in the list
        headers = list(details[0].keys())
        header_widths = [35] * len(headers)  # Default column widths, adjust as needed

        # Print headers
        for i, header in enumerate(headers):
            pdf.cell(header_widths[i], 8, header, border=1, align='C')
        pdf.ln()

        # Table Rows
        pdf.set_font("Arial", "", 9)
        for detail in details:
            for i, header in enumerate(headers):
                value = detail.get(header, '')
                align = 'R' if isinstance(value, (int, float, Decimal)) else 'L'
                pdf.cell(header_widths[i], 8, str(value), border=1, align=align)
            pdf.ln()

        # Add Totals Row
        # Identify numeric columns dynamically
        numeric_headers = [header for header in headers if isinstance(details[0].get(header, 0), (int, float, Decimal))]

        totals = {header: Decimal(0) for header in numeric_headers}
        for detail in details:
            for header in numeric_headers:
                totals[header] += Decimal(detail.get(header, 0))

        pdf.set_font("Arial", "B", 9)
        pdf.cell(header_widths[0], 8, 'Total', border=1, align='R')
        for i, header in enumerate(headers[1:]):  # Exclude the 'Total' header
            if header in totals:
                value = totals.get(header, Decimal(0))
                pdf.cell(header_widths[i + 1], 8, str(value), border=1, align='R')
            else:
                pdf.cell(header_widths[i + 1], 8, '', border=1)  # For non-numeric columns
        pdf.ln()

        # pdf.set_font("Arial", "", 9)
        # pdf.cell(0, 6, "pdf generated by:", ln=True)
        # pdf.cell(0, 6, "www.innalytics.in", ln=True)

        base_dir = os.getenv("FILE_PATH", '../temp')
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        Out_path = os.path.join(base_dir, str(uuid.uuid4()) + ".pdf")
        pdf.output(Out_path, 'F')
        out = PdfWriter()
        file = PdfReader(Out_path)
        num = len(file.pages)
        for idx in range(num):
            page = file.pages[idx]
            out.add_page(page)
        with open(Out_path, "wb") as f:
            out.write(f)
        return Out_path

    except Exception as e:
        print(str(e))

def get_item_pdf(details, request, rpt_name, decoded):
    try:
        pdf = PDF()
        pdf.add_page()

        pdf.set_font("Arial", "B", 12)
        pdf.cell(0, 10, decoded.get('comp_name', 'Company Name'), ln=True, align='C')
        pdf.ln(5)

        # Title
        pdf.set_font("Arial", "B", 10)
        pdf.cell(0, 10, rpt_name, ln=True, align='C')
        pdf.ln(10)

        # Iterate through data
        for location, types in details.items():
            # Location Header
            pdf.set_font("Arial", "B", 9)
            pdf.cell(0, 10, f"Location: {location}", ln=True)
            pdf.ln(1)

            for type_name, items in types.items():
                # Type Header
                pdf.set_font("Arial", "B", 9)
                pdf.cell(0, 10, f"Type: {type_name}", ln=True)
                pdf.ln(2)

                # Define headers dynamically
                headers = list(items[0].keys()) if items else []

                # Set the width for the "Count" column and share remaining width among other columns
                total_page_width = 195  # Approximate page width in mm (A4 minus margins)
                count_column_width = 95  # Fixed width for the "Count" column
                remaining_width = total_page_width - count_column_width
                other_columns = [h for h in headers if h != 'Count']
                other_column_width = remaining_width / len(other_columns) if other_columns else remaining_width

                # Table Headers
                pdf.set_font("Arial", "B", 9)
                for header in headers:
                    if header == 'Count':
                        pdf.cell(count_column_width, 10, header, 1, 0, 'C')
                    else:
                        pdf.cell(other_column_width, 10, header, 1, 0, 'C')
                pdf.ln()

                # Table Rows
                pdf.set_font("Arial", "", 8)
                for item in items:
                    for idx, header in enumerate(headers):
                        align = 'L' if header == 'Count' else 'C'  # Left-align 'Count', center-align others
                        if header == 'Count':
                            pdf.cell(count_column_width, 10, str(item[header]), 1, 0, align)
                        else:
                            pdf.cell(other_column_width, 10, str(item[header]), 1, 0, align)
                    pdf.ln()

                pdf.ln(5)  # Add space between types

            pdf.ln(10)

        # Save the PDF to a file
        base_dir = os.getenv("FILE_PATH", '../temp')
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        Out_path = os.path.join(base_dir, str(uuid.uuid4()) + ".pdf")
        pdf.output(Out_path, 'F')

        # Save and return the final PDF
        out = PdfWriter()
        file = PdfReader(Out_path)
        num = len(file.pages)
        for idx in range(num):
            page = file.pages[idx]
            out.add_page(page)
        with open(Out_path, "wb") as f:
            out.write(f)
        return Out_path

    except Exception as e:
        print(str(e))
def calculate_column_widths(items, headers, pdf):
    # Initialize widths with the header widths
    column_widths = {header: pdf.get_string_width(header) + 4 for header in headers}

    # Calculate the width needed for each column based on the data
    for item in items:
        for header in headers:
            content_width = pdf.get_string_width(str(item[header])) + 4
            if content_width > column_widths[header]:
                column_widths[header] = content_width

    return column_widths

# --------------> frame pdf starts here

def get_frame_stock_report_report_table(request, decoded):
    try:
        config_details = get_table_config_details(request, decoded)
        if config_details and len(config_details) > 0:
            details, rpt_name, file_name = get_details(config_details[0][0], config_details[0][1], request)
            return {"details": details, "rpt_name": rpt_name, "file_name": file_name}
    except Exception as e:
        print(str(e))


def get_table_config_details(request, decoded):
    try:
        qry = ("select report_table,report_config_fk from Reporting.main_menu where comp_fk='{0}' and "
               "menupk='{1}'").format(decoded['comp_fk'], request['menu_pk'])
        res = py_connection.get_result(qry)
        if res and len(res) > 0:
            return res
        else:
            return res
    except Exception as e:
        print(str(e))
        return []

def get_details(report_table, report_config_fk, request):
    try:
        qry = ("select frame_rpt_name, frame_file_name, frame_rpt_pdf from Reporting." + str(report_table) +
               " where report_config_pk =" + str(report_config_fk))
        res = py_connection.get_result(qry)
        if res and len(res) > 0:
            item_details = get_frame_details(res[0][2], request), res[0][0], res[0][1]
            return item_details
        else:
            return []
    except Exception as e:
        print(str(e))
        return []


def get_frame_details(procedure_name, request):
    try:
        # Extract date from request or use a default value
        # date_str = '2024-09-01'
        date_str = request.get("date")
        date_obj = dt.strptime(date_str, '%Y-%m-%d')
        previous_date_str = (date_obj - timedelta(days=1)).strftime('%Y-%m-%d')

        # Build the query string
        qry = '{call Reporting.' + str(procedure_name) + '(?)}'

        # Call the stored procedure
        res, k = py_connection.call_prop1(qry, (date_str,))

        # Check if the result is valid and contains data
        if res and len(res) > 0:
            result = {}
            for record in res:
                category = record[0]
                subcategory = record[1]
                lot_no = record[2]
                bags_pallet = record[3]
                loose_cones = record[4]
                no_of_rf = record[5]
                delivery_bags = record[6]
                pending_order = record[7]

                # Initialize nested dictionary structure if not already present
                if category not in result:
                    result[category] = {}
                if subcategory not in result[category]:
                    result[category][subcategory] = []

                # Append the record as a dictionary
                result[category][subcategory].append({
                    k[2]: lot_no,
                    k[3]: bags_pallet,
                    k[4]: loose_cones,
                    k[5]: no_of_rf,
                    "delivery on " + str(previous_date_str): delivery_bags,
                    k[7]: pending_order
                })
            return result
        else:
            print("No valid data returned from the stored procedure.")
            return {}
    except Exception as e:
        print(str(e))
        return {}


def get_frame_pdf(details, request, rpt_name, decoded):
    try:
        pdf = PDF()
        pdf.add_page()

        # Company Name
        pdf.set_font("Arial", "B", 12)
        pdf.cell(0, 10, decoded.get('comp_name', 'Company Name'), ln=True, align='C')
        pdf.ln(5)

        # Report Name
        pdf.cell(0, 10, rpt_name, ln=True, align='C')
        pdf.ln(10)

        # Define headers with the first column as 'Count'
        columns = ['Count']
        for section, items in details.items():
            for key, item_list in items.items():
                for item in item_list:
                    for key1 in item.keys():
                        if key1 not in columns:
                            columns.append(key1)

        # Set column widths
        col_widths = [100]  # Fixed width for the 'Count' column
        total_width = 195  # Assuming total width of 195 mm for A4 minus margins
        remaining_width = total_width - col_widths[0]

        if len(columns) > 1:
            dynamic_width = remaining_width / (len(columns) - 1)
        else:
            dynamic_width = remaining_width  # If there's only one column other than 'Count'

        col_widths.extend([dynamic_width] * (len(columns) - 1))

        # Header Titles
        pdf.set_font("Arial", "B", 6)
        max_header_height = 15

        for i, column in enumerate(columns):
            x_start = pdf.get_x()
            y_start = pdf.get_y()
            pdf.cell(col_widths[i], max_header_height, '', border=1, align='C')
            pdf.set_xy(x_start + 1, y_start + (10 - 6) / 2)
            pdf.multi_cell(col_widths[i] - 2, 6, column, border=0, align='C')
            pdf.set_xy(x_start + col_widths[i], y_start)
        pdf.ln(max_header_height)
        pdf.ln(5)

        # Initialize overall totals with before and after sums for each column
        overall_totals = {key: {'before_sum': 0, 'after_sum': 0} for key in columns[1:]}

        # Iterate through items
        for section, items in details.items():
            # Section Title
            pdf.set_font("Arial", "B", 10)
            pdf.cell(0, 10, section, ln=True, align='L')
            pdf.ln(2)

            pdf.set_font("Arial", "", 9)
            section_totals = {key: {'before_sum': 0, 'after_sum': 0} for key in columns[1:]}

            for key, item_list in items.items():
                num_rows = len(item_list)
                row_height = 5  # Adjust based on your needs
                total_height = row_height * num_rows

                # First row with Count key
                pdf.cell(col_widths[0], total_height, key, border=1, align='L', ln=False)

                # Fill in other columns for the first row
                for j, column in enumerate(columns[1:], start=1):
                    value = item_list[0].get(column, '-')
                    before_sum, after_sum = 0, 0
                    if '/' in value:
                        before, after = value.split('/')
                        before_sum = int(before) if before.replace('.', '', 1).isdigit() else 0
                        after_sum = int(after) if after.replace('.', '', 1).isdigit() else 0
                    else:
                        before_sum = int(value) if value.replace('.', '', 1).isdigit() else 0

                    # Update section totals
                    section_totals[column]['before_sum'] += before_sum
                    section_totals[column]['after_sum'] += after_sum

                    # Display the cell value in the PDF
                    pdf.cell(col_widths[j], row_height, str(value), border=1, align='C')
                pdf.ln(row_height)

                # Remaining rows without Count key
                for i in range(1, num_rows):
                    pdf.cell(col_widths[0], row_height, "", border=0, align='C', ln=False)
                    for j, column in enumerate(columns[1:], start=1):
                        value = item_list[i].get(column, '-')
                        before_sum, after_sum = 0, 0
                        if '/' in value:
                            before, after = value.split('/')
                            before_sum = int(before) if before.replace('.', '', 1).isdigit() else 0
                            after_sum = int(after) if after.replace('.', '', 1).isdigit() else 0
                        else:
                            before_sum = int(value) if value.replace('.', '', 1).isdigit() else 0

                        # Update section totals
                        section_totals[column]['before_sum'] += before_sum
                        section_totals[column]['after_sum'] += after_sum

                        # Display the cell value in the PDF
                        pdf.cell(col_widths[j], row_height, str(value), border=1, align='C')
                    pdf.ln(row_height)

            # Add section subtotal row
            pdf.set_font("Arial", "B", 9)
            pdf.cell(col_widths[0], row_height, "Sub Total", border=1, align='L', ln=False)
            for j, column in enumerate(columns[1:], start=1):
                if column == 'Lot No':
                    pdf.cell(col_widths[j], row_height, "", border=1, align='C')
                else:
                    before_total = section_totals[column]['before_sum']
                    after_total = section_totals[column]['after_sum']
                    pdf.cell(col_widths[j], row_height, f"{before_total}/{after_total}", border=1, align='C')

                    # Update overall totals
                    overall_totals[column]['before_sum'] += before_total
                    overall_totals[column]['after_sum'] += after_total
            pdf.ln(row_height)
            pdf.ln(5)

        # Add overall totals row
        pdf.set_font("Arial", "B", 9)
        pdf.cell(col_widths[0], row_height, "Total", border=1, align='L', ln=False)
        for j, column in enumerate(columns[1:], start=1):
            if column == 'Lot No':
                pdf.cell(col_widths[j], row_height, "", border=1, align='C')
            else:
                before_total = overall_totals[column]['before_sum']
                after_total = overall_totals[column]['after_sum']
                pdf.cell(col_widths[j], row_height, f"{before_total}/{after_total}", border=1, align='C')
        pdf.ln(row_height)
        pdf.ln(5)

        # Save PDF to file
        base_dir = os.getenv("FILE_PATH", '../temp')
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        Out_path = os.path.join(base_dir, str(uuid.uuid4()) + ".pdf")
        pdf.output(Out_path, 'F')

        return Out_path

    except Exception as e:
        print(str(e))




# def get_frame_pdf(details, request, rpt_name, decoded):
#     try:
#         pdf = PDF()
#         pdf.add_page()
#
#         # Company Name
#         pdf.set_font("Arial", "B", 12)
#         pdf.cell(0, 10, decoded.get('comp_name', 'Company Name'), ln=True, align='C')
#         pdf.ln(5)
#
#         # Report Name
#         pdf.cell(0, 10, rpt_name, ln=True, align='C')
#         pdf.ln(10)
#
#         # Define headers with the first column as 'Count'
#         columns = ['Count']
#         for section, items in details.items():
#             for key, item_list in items.items():
#                 for item in item_list:
#                     for key1 in item.keys():
#                         if key1 not in columns:
#                             columns.append(key1)
#
#         # Set column widths
#         col_widths = [100]  # Fixed width for the 'Count' column
#         total_width = 195  # Assuming total width of 195 mm for A4 minus margins
#         remaining_width = total_width - col_widths[0]
#
#         if len(columns) > 1:
#             dynamic_width = remaining_width / (len(columns) - 1)
#         else:
#             dynamic_width = remaining_width  # If there's only one column other than 'Count'
#
#         col_widths.extend([dynamic_width] * (len(columns) - 1))
#
#         # Header Titles
#         pdf.set_font("Arial", "B", 6)
#         max_header_height = 15
#
#         for i, column in enumerate(columns):
#             x_start = pdf.get_x()
#             y_start = pdf.get_y()
#             pdf.cell(col_widths[i], max_header_height, '', border=1, align='C')
#             pdf.set_xy(x_start + 1, y_start + (10 - 6) / 2)
#             pdf.multi_cell(col_widths[i] - 2, 6, column, border=0, align='C')
#             pdf.set_xy(x_start + col_widths[i], y_start)
#         pdf.ln(max_header_height)
#         pdf.ln(5)
#         # Initialize overall totals
#         overall_totals = {key: 0 for key in columns[1:] if key != 'Lot No'}
#
#         # Iterate through items
#         for section, items in details.items():
#             # Section Title
#             pdf.set_font("Arial", "B", 10)
#             pdf.cell(0, 10, section, ln=True, align='L')
#             pdf.ln(2)
#
#             pdf.set_font("Arial", "", 9)
#             section_totals = {key: 0 for key in columns[1:] if key != 'Lot No'}  # Initialize section totals
#
#             for key, item_list in items.items():
#                 # Calculate height for Count key spanning multiple rows
#                 num_rows = len(item_list)
#                 row_height = 5  # Adjust based on your needs
#                 total_height = row_height * num_rows
#
#                 # First row with Count key
#                 pdf.cell(col_widths[0], total_height, key, border=1, align='L', ln=False)
#
#                 # Fill in other columns for the first row
#                 for j, column in enumerate(columns[1:], start=1):
#                     value = item_list[0].get(column, '-')
#                     if column != 'Lot No':
#                         value_sum = sum(float(v) for v in value.split('/') if v.replace('.', '', 1).isdigit())
#                         section_totals[column] += value_sum
#
#                     pdf.cell(col_widths[j], row_height, str(value), border=1, align='C')
#                 pdf.ln(row_height)
#
#                 # Remaining rows without Count key
#                 for i in range(1, num_rows):
#                     pdf.cell(col_widths[0], row_height, "", border=0, align='C', ln=False)
#                     for j, column in enumerate(columns[1:], start=1):
#                         value = item_list[i].get(column, '-')
#                         if column != 'Lot No':
#                             value_sum = sum(float(v) for v in value.split('/') if v.replace('.', '', 1).isdigit())
#                             section_totals[column] += value_sum
#
#                         pdf.cell(col_widths[j], row_height, str(value), border=1, align='C')
#                     pdf.ln(row_height)
#
#             # Add subtotals row
#             pdf.set_font("Arial", "B", 9)
#             pdf.cell(col_widths[0], row_height, "Sub Total", border=1, align='L', ln=False)
#             for j, column in enumerate(columns[1:], start=1):
#                 if column == 'Lot No':
#                     pdf.cell(col_widths[j], row_height, "", border=1, align='C')
#                 else:
#                     int_total = int(section_totals[column])  # Convert to int
#                     pdf.cell(col_widths[j], row_height, str(int_total), border=1, align='C')
#                     overall_totals[column] += section_totals[column]  # Add section total to overall total
#             pdf.ln(row_height)
#             pdf.ln(5)  # Add some space after the subtotals row
#
#         # Add overall totals row
#         pdf.set_font("Arial", "B", 9)
#         pdf.cell(col_widths[0], row_height, "Total", border=1, align='L', ln=False)
#         for j, column in enumerate(columns[1:], start=1):
#             if column == 'Lot No':
#                 pdf.cell(col_widths[j], row_height, "", border=1, align='C')
#             else:
#                 int_total = int(overall_totals[column])  # Convert to int
#                 pdf.cell(col_widths[j], row_height, str(int_total), border=1, align='C')
#         pdf.ln(row_height)
#         pdf.ln(5)  # Add some space after the totals row
#
#         # Save PDF to file
#         base_dir = os.getenv("FILE_PATH", '../temp')
#         if not os.path.exists(base_dir):
#             os.makedirs(base_dir)
#         Out_path = os.path.join(base_dir, str(uuid.uuid4()) + ".pdf")
#         pdf.output(Out_path, 'F')
#
#         return Out_path
#
#     except Exception as e:
#         print(str(e))